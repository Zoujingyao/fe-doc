---
group:
  title: 热题100
  path: /algorithm/hot100
---

# [155. 最小栈](https://leetcode.cn/problems/min-stack/?favorite=2cktkvj)

## 思路

这道题我在底部实现了一个堆和一个栈，模拟操作，而且在 stack 进行 pop 操作的时候，即栈顶的元素弹出时，该元素在堆中的位置不清楚，所以我只能如果在堆顶执行删除，否则先不管；

然后获取当前最小值的时候，看堆顶元素是否在栈中，不在就执行堆的删除操作，重复该过程，直到堆顶是目前栈中的元素，也就是最小值。

这个实现好蠢啊，下次不要遇到数据结构就开始手写！官方题解：

```text
对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。

因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。

那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。
```

这样只需要一个 stack: number[]，然后再需要一个 curMin: number[]，curMin[i]表示当栈顶元素为 stack[i]时，当前最小的元素；

每次入栈 x 的时候除了 stack.push(x)外，curMin.push(Math.min(curMin[len-1], x));

每次出栈的时候 stack 和 curMin 同时执行 pop 操作；

这样栈顶就是 stack[len-1], 当前最小的元素就是 curMin[len-1];

【我恨啊，就当复习堆了，还是没仔细想栈的特性】

## 代码

<code src='./index.tsx'></code>
